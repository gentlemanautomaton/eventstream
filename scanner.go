package eventstream

import (
	"bufio"
	"bytes"
	"io"
)

// Scanner reads event stream tokens from an underlying io.Reader. Each token
// represents a line of input.
type Scanner struct {
	lines   *bufio.Scanner
	started bool
}

// NewScanner returns a new event stream token scanner that reads from r.
func NewScanner(r io.Reader) *Scanner {
	return &Scanner{lines: bufio.NewScanner(r)}
}

// Buffer has the same behavior as Scanner.Buffer in the standard library's
// bufio package.
func (s *Scanner) Buffer(buf []byte, max int) {
	s.lines.Buffer(buf, max)
}

// Scan advances the scanner to the next token, which will then be available
// through the Token method. It returns false when the scan stops, either by
// reaching the end of the stream or an error.
func (s *Scanner) Scan() bool {
	if !s.lines.Scan() {
		return false
	}
	return true
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	return s.lines.Err()
}

// Token returns the most recent token generated by a call to Scan.
//
// A token is only valid until the next call to Scan, after which its
// underlying data may be overwritten.
func (s *Scanner) Token() Token {
	// Collect the current line from bufio.Scanner
	line := s.lines.Bytes()

	// Skip the opening byte order mark if it's present
	if !s.started {
		s.started = true
		if len(line) >= 3 && line[0] == 0xEF && line[1] == 0xBB && line[2] == 0xBF {
			line = line[3:]
		}
	}

	// Empty lines signal the end of a section
	if len(line) == 0 {
		return Token{line: line, colon: -1}
	}

	// Non-empty lines are interpreted according to the presence of a colon
	colon := bytes.IndexRune(line, ':')
	return Token{line: line, colon: colon}
}
